import sysimport numpy as npimport torchimport torch.nn as nnimport matplotlib.pyplot as pltfrom numpy import asarrayfrom PIL import Imagefrom scipy.stats import multivariate_normal as mvnimport cv2# 2.1def convolve(pixels, conv_filter):    """    Returns the discrete, linear convolution of two dimensional sequences.    If `v` is longer than `a`, the arrays are swapped before computation.    Parameters    ----------    :param image: (N,) array_like. First one-dimensional input array    :param filter: (M,) array_like. Second one-dimensional input array    :return: ndarray (Discrete, linear convolution of `a` and `v`)    Note    ----    Convolve function will not make the convolve operation.    If conditions are met, convolve operation will call function conv_    """    # Convolving with RGB images: Check if number of channels matches the filter depth    # Check if filter dimensions are equal.    if conv_filter.shape[0] != conv_filter.shape[1]:        print('Error: Filter must be a square matrix.')        sys.exit()    # Check if the filter dimensions are odd    if (conv_filter.shape[0] * conv_filter.shape[1]) % 2 == 0:        print("Error: Filter must have an odd size")        sys.exit()    # Feature map to hold the output of convolving the filter with the image    feature_map = np.zeros(pixels.shape)    # # Convolving the image by the filters    # for filter_number in range(conv_filter.shape[0]):    #     print("Filter number: ", filter_number + 1)    #     # Getting filter from the bank    #     current_filter = conv_filter[filter_number, :]    # ToDo: Convolving pixels with more than 1 channel.    # if conv_filter.shape[2] > 1:    #     pass    #     # # Array holding the sum of all feature maps    #     # conv_map = conv_(image[:, :, 0], current_filter[:, :, 0])    #     #    #     # # Convolving each channel with the image and summing the results.    #     # for channel_number in range(1, current_filter.shape()[-1]):    #     #     conv_map = conv_map + conv_(image[:, :, channel_number],    #     #                                 current_filter[:, :, channel_number])    #    # # There is only a single channel to convolve    # else:    conv_map = conv_(pixels, conv_filter)    # Holding feature map with the current filter.    feature_map[:, :] = conv_map    return feature_mapdef conv_(image, conv_filter):    # conv_filter[0] == conv_filter[1]    filter_width = conv_filter.shape[0]    filter_height = conv_filter.shape[0]    image_width, image_height = image.shape[0], image.shape[1]    width = filter_width // 2    height = filter_height // 2    convolved_image = np.zeros(image.shape)    for i in range(height, image_height - height):        for j in range(width, image_width - width):            sum_of_pixel = 0            for k in range(filter_height):                for l in range(filter_width):                    sum_of_pixel = sum_of_pixel + conv_filter[k][l] * image[i - height + k][j - width + l]            convolved_image[i][j] = sum_of_pixel    return convolved_imagedef convolving(image, kernel):    assert kernel.shape[0] == kernel.shape[1]    imageArr = np.asarray(image)    resX = imageArr.shape[0] - kernel.shape[0]    resY = imageArr.shape[1] - kernel.shape[1]    filteredImageArr = np.empty((resX, resY))    for xi, yi in np.ndindex(filteredImageArr.shape):        filteredImageArr[xi, yi] = np.sum(np.multiply(imageArr[xi:xi + kernel.shape[0], yi: yi + kernel.shape[            1]], kernel))        filteredImage = Image.fromarray(filteredImageArr)        filteredImage = filteredImage.convert("L")        return filteredImage# 2.2def gaussian(x, sigma, mu=None):    if mu is None:        return mvn.pdf(x, cov=sigma)    else:        return mvn.pdf(x, mean=mu, cov=sigma)def gaussian_kernel(n, sigma, mu):    _sum = 0    kernel = np.zeros((n, n))    step = int(n / 2) + 1    for i in range(1, n + 1):        for j in range(1, n + 1):            v = gaussian(                x=[i - step, j - step],                mu=[0.0, 0.0],                sigma=[sigma, sigma]            )            _sum += v            kernel[i - 1][j - 1] = v    print(_sum)    # Return reshaped version    return kernel.reshape((n, n))def main():    T = gaussian_kernel(n=201, sigma=500, mu=0)    print("Shape of matrix T={} and the sum is {}".format(T.shape, T.sum()))    # Normalize to the range 0-1. Resize by 255 and convert array to uint8    T = np.uint8(T / (T.max()/255))    print('Min: %3.f, Max: %3.f' % (T.min(), T.max()))    print("Dimensions of kernel: ", T.ndim)    print("Shape of the kernel: ", T.shape)    pil_filter = Image.fromarray(T)    pil_filter.show()    image_name = "dog.jpg"    image = Image.open(image_name)    image = image.convert(mode='L')    pixels = asarray(image)    pixels_future_image_tensor = pixels    print("Dimension of the image: ", pixels.ndim)    print("Shape of the pixels", pixels.shape)    # print(pixels)    # Convert pixels from integers to float    pixels = pixels.astype('float32')    # Normalize to the range 0-1    pixels /= 255    print('Min: %3.f, Max: %3.f' % (pixels.min(), pixels.max()))    convolved_image = Convolving(pixels=pixels, conv_filter=T)    conv_image = Image.fromarray(convolved_image)    conv_image.show()    # 3.1    # Load the image    # image = Image.open("dog.jpg")    # image.show(title="Doggy", command=None)    # Convert image to numpy array    # data = np.array(image)    # print(type(data))    # print(data.flags)    # Summarize shape    # print(data.shape)    # Print value of each pixel of the NumPy array image    # print(data)    # # Create Pillow image    # reverse_image = Image.fromarray(data)    # print(type(reverse_image))    # # Summarize image details    # print(reverse_image.mode)    # print(reverse_image.size)    # From numpy array to torch tensor    # torch_data_tensor = torch.from_numpy(data)    # print(torch_data_tensor.size())    # Change axis of tensor    # permuted_torch_data_tensor = torch_data_tensor.permute(1, 2, 0)    # print(permuted_torch_data_tensor.size())    # From torch tensor to numpy array    # numpy_array = permuted_torch_data_tensor.numpy()    # print(numpy_array.shape)    # reversed_image = Image.fromarray(np.uint8(numpy_array))    # reversed_image = Image.fromarray((numpy_array * 255).astype(np.uint8))    # reversed_image.save("reversedImage.jpg")    # reversed_image.show(title="Reversed Image", command=None)    # 3.2    x = np.random.rand(5, 5, 1)    # print(x)    w = np.random.rand(2, 2, 1)    # # Creating nn.Conv2d object with in_channels = 1, out_channels = 1, kernel_size = 2, and bias = false    conv = torch.nn.Conv2d(in_channels=1, out_channels=1, kernel_size=3, bias=False)    print(conv.weight.shape)    # Converting x and w to PyTorch tensors and swapping axes    x_PyTorch_tensor = torch.from_numpy(x)    permuted_tensor_x = x_PyTorch_tensor.permute(2, 0, 1)    w_PyTorch_tensor = torch.from_numpy(w)    permuted_tensor_w = w_PyTorch_tensor.permute(2, 0, 1)    # Adding dimension to x and w    permuted_tensor_x.unsqueeze_(0)    permuted_tensor_w.unsqueeze_(0)    print(permuted_tensor_w.shape)    print(permuted_tensor_x.shape)    # Adding weight with w tensor    conv.weight = torch.nn.Parameter(permuted_tensor_w)    # Convolving image x    output_array = conv(permuted_tensor_x)    print("Output shape: ", output_array.shape)    # Convolving image with Gaussian filter    image_PyTorch_tensor = torch.from_numpy(pixels_future_image_tensor)    print(image_PyTorch_tensor.shape)    gaussian_PyTorch_tensor = torch.from_numpy(np.float32(T))    print(gaussian_PyTorch_tensor.shape)    if image_PyTorch_tensor.dtype == gaussian_PyTorch_tensor.dtype:        # permuted_tensor_image = image_PyTorch_tensor.permute(2, 0, 1)        # permuted_tensor_gaussian_filter = gaussian_PyTorch_tensor.permute(2, 0, 1)        # permuted_tensor_image.unsqueeze_(0)        # permuted_tensor_gaussian_filter.unsqueeze_(0)        image_PyTorch_tensor.unsqueeze_(0)        gaussian_PyTorch_tensor.unsqueeze_(0)        # conv.weight = torch.nn.Parameter(permuted_tensor_gaussian_filter)        conv.weight = torch.nn.Parameter(gaussian_PyTorch_tensor)        # output_image_array = conv(permuted_tensor_image)        # print("Output image.shape: ", output_image_array.shape)        output_image_array = conv(image_PyTorch_tensor)        print("Output image.shape: ", output_image_array.shape)if __name__ == "__main__":    main()