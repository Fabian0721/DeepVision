from numpy import expand_dims, asarrayimport numpy as npimport cv2from PIL import Imageimport randomrefPt = []# Trying to patch where the user clicksdef click_and_patching(event, image, x, y):    global refPt    if event == cv2.EVENT_LBUTTONDOWN:        refPt = [(x, y)]    elif event == cv2.EVENT_LBUTTONUP:        refPt.append((x, y))        cv2.rectangle(image, refPt[0], refPt[1], thickness=5)        cv2.rectangle(image, refPt[0], refPt[1], (0, 0, 0), thickness=5)        cv2.imshow("Image", image)# Select random square patch patchdef select_random_patch(width, height, square_side):    while True:        random_coordinates = abs(random.randint(0, width)), abs(random.randint(0, height))        # Prove if random patch can be constructed downwards (cannot be constructed downwards)        if abs(height - random_coordinates[1]) < square_side:            # Prove if random patch can be constructed upwards (cannot be constructed upwards)            if random_coordinates[1] < square_side:                pass            # Can be constructed upwards            else:                # Prove if random patch can be constructed to the right (cannot be constructed to the right)                if abs(width - random_coordinates[0]) < square_side:                    # Prove if random patch can be constructed to the left (cannot be constructed to the left)                    if random_coordinates[0] < 250:                        pass                    # Can be constructed to the left. Random coordinates represent the bottom left corner of the random patch                    else:                        right_lower = random_coordinates[0], random_coordinates[1]                        left_upper = random_coordinates[0] - square_side, random_coordinates[1] - square_side                        return left_upper, right_lower                # Can be constructed to the right. Random coordinates represent the bottom right corner of the random patch                else:                    right_lower = random_coordinates[0] + square_side, random_coordinates[1]                    left_upper = random_coordinates[0], random_coordinates[1] - square_side                    return left_upper, right_lower        # Can be constructed downwards        else:            # Prove if random patch can be constructed to the right (cannot be constructed to the right)            if abs(width - random_coordinates[0]) < square_side:                # Prove if random patch can be constructed to the left (cannot be constructed to the left)                if random_coordinates[0] < square_side:                    pass                # Can be constructed to the left. Random coordinates represent the top right corner of the random patch                else:                    right_lower = random_coordinates[0], random_coordinates[1] + square_side                    left_upper = random_coordinates[0] - square_side, random_coordinates[1]                    return left_upper, right_lower            # Can be constructed to the right. Random coordinates represent the top left corner of the random patch            else:                right_lower = random_coordinates[0] + square_side, random_coordinates[1] + square_side                left_upper = random_coordinates[0], random_coordinates[1]                return left_upper, right_lowerdef patch_in_image(left_upper_coordinate, background, patch):    background.paste(patch, left_upper_coordinate)    background.save("patchDog.jpg")def main():    # load the image    image_name = "dog.jpg"    image = Image.open(image_name)    image.show(title="Image Loaded", command=None)    print(image.size)    print(type(image.size))    data = asarray(image)    print(data.shape)    data_edges = select_random_patch(image.size[0], image.size[1], square_side=256)    data_edge_array = [data_edges[0][0], data_edges[0][1], data_edges[1][0], data_edges[1][1]]    print(data_edges)    print(data_edge_array)    crop_image = image.crop(data_edge_array)    print(crop_image)    crop_image.show(title="Crop Image", command=None)    crop_image = crop_image.convert(mode='L')    print(crop_image.size)    crop_image.show(title="Crop Image in grayscale", command=None)    # print(image.getpixel((0, 0)))    # print(crop_image.getpixel((0, 0)))    patch_in_image(data_edges[0], image, crop_image)    (new_width, new_height) = (image.width // 2, image.height // 2)    image_resized = image.resize((new_width, new_height))    image_resized.show(title="Patched Image", command=None)    # image = cv2.imread("dog.jpg")    # clone = image.copy()    # cv2.namedWindow("Image")    # cv2.setMouseCallback("image", click_and_patching())    #    # refPt = []    #    # while True:    #     cv2.imshow("dog.jpg", image)    #     key = cv2.waitKey(0) & 0xFF    #    #     if key == ord("r"):    #         image = clone.copy()    #    #     elif key == ord(c):    #         break;    #    #     if len(refPt) == 2:    #         roi = clone[refPt[0][1]:refPt[1][1], refPt[0][0]:refPt[1][0]]    #         cv2.imshow("ROI", roi)    #         cv2.waitKey(0)    #    #     cv2.destroyAllWindows()if __name__ == "__main__":    main()