import ConvolveAndKernelimport Patchingimport torchfrom numpy import expand_dims, asarrayimport numpy as npimport cv2from PIL import Imageimport randomdef exercise1():    # load the image       image_name = "dog.jpg"       image = Image.open(image_name)       image.show(title="Image Loaded", command=None)       print(image.size)       print(type(image.size))       data = asarray(image)       print(data.shape)       data_edges = select_random_patch(image.size[0], image.size[1], square_side=256)       data_edge_array = [data_edges[0][0], data_edges[0][1], data_edges[1][0], data_edges[1][1]]       print(data_edges)       print(data_edge_array)       crop_image = image.crop(data_edge_array)       print(crop_image)       crop_image.show(title="Crop Image", command=None)       crop_image = crop_image.convert(mode='L')       print(crop_image.size)       crop_image.show(title="Crop Image in grayscale", command=None)       # print(image.getpixel((0, 0)))       # print(crop_image.getpixel((0, 0)))       patch_in_image(data_edges[0], image, crop_image)       (new_width, new_height) = (image.width // 2, image.height // 2)       image_resized = image.resize((new_width, new_height))       image_resized.show(title="Patched Image", command=None)       image = cv2.imread("dog.jpg")       clone = image.copy()       cv2.namedWindow("Image")       cv2.setMouseCallback("image", click_and_patching())       refPt = []       while True:           cv2.imshow("dog.jpg", image)           key = cv2.waitKey(0) & 0xFF           if key == ord("r"):               image = clone.copy()           elif key == ord(c):               break;           if len(refPt) == 2:               roi = clone[refPt[0][1]:refPt[1][1], refPt[0][0]:refPt[1][0]]               cv2.imshow("ROI", roi)               cv2.waitKey(0)           cv2.destroyAllWindows()           def e2():def e3():def main():    e1()    e2()    e3()       """    Exercise 2:    """    image_name = "dog.jpg"    image = Image.open(image_name)    # data = asarray(image)    # print(data.shape)    image = image.convert(mode='L')    data = asarray(image)    # print(data_gray.shape)    print(data.ndim)    # h, w = data.shape()    n = 3    # One filter on the first layer    l1_filter = np.zeros((1, n, n))    print(l1_filter.ndim)    print(l1_filter)    l1_filter[0, :, :] = np.array([[[-1, 0, 1],                                    [-1, 0, 1],                                    [-1, 0, 1]]])    print(l1_filter.shape)    print(l1_filter)    """    Exercise 3:    """    # Load the image    image = Image.open("dog.jpg")    # image.show(title="Doggy", command=None)    # Convert image to numpy array    data = np.array(image)    print(type(data))    print(data.flags)    # Summarize shape    print(data.shape)    # Print value of each pixel of the NumPy array image    # print(data)    # # Create Pillow image    # reverse_image = Image.fromarray(data)    # print(type(reverse_image))    # # Summarize image details    # print(reverse_image.mode)    # print(reverse_image.size)    # From numpy array to torch tensor    torch_data_tensor = torch.from_numpy(data)    print(torch_data_tensor.size())    # Change axis of tensor    permuted_torch_data_tensor = torch_data_tensor.permute(1, 2, 0)    print(permuted_torch_data_tensor.size())    # From torch tensor to numpy array    numpy_array = permuted_torch_data_tensor.numpy()    print(numpy_array.shape)    # reversed_image = Image.fromarray(np.uint8(numpy_array))    # reversed_image = Image.fromarray((numpy_array * 255).astype(np.uint8))    # reversed_image.save("reversedImage.jpg")    # reversed_image.show(title="Reversed Image", command=None)    x = np.random.rand(5, 5, 1)    # print(x)    w = np.random.rand(2, 2, 1)    conv = torch.nn.Conv2d(in_channels=1, out_channels=1, kernel_size=3, bias=False)    print(conv.shape)    x_PyTorch_tensor = torch.from_numpy(x)    x_PyTorch_tensor.permute(2, 1, 0)    w_PyTorch_tensor = torch.from_numpy(w)    w_PyTorch_tensor.permute(2, 1, 0)    x_PyTorch_tensor.unsqueeze_(0)    w_PyTorch_tensor.unsqueeze_(0)    conv.weight = torch.nn.Parameter(w)    x = torch.nn.Conv2d(w)    print(x.shape)    x.show()if __name__== "__main__":    main()