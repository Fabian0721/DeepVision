import sysimport numpy as npfrom numpy import asarrayfrom PIL import Imagedef convolve(image, conv_filter):    """    Returns the discrete, linear convolution of two dimensional sequences.    If `v` is longer than `a`, the arrays are swapped before computation.    Parameters    ----------    :param image: (N,) array_like. First one-dimensional input array    :param filter: (M,) array_like. Second one-dimensional input array    :return: ndarray (Discrete, linear convolution of `a` and `v`)    Note    ----    Convolve function will not make the convolve operation.    If conditions are met, convolve operation will call function conv_    """    # Convolving with RGB images    if len(image.shape()) > 2 or len(conv_filter) > 3:        # Check if number of channels matches the filter depth        if image.shape()[-1] == conv_filter.shape[-1]:            print("Error: Number of channels in image must be the same to the number of channels in the filter")            sys.exit()    # Check if filter dimensions are equal.    if conv_filter.shape[0] != conv_filter.shape[1]:        print('Error: Filter must be a square matrix.')        sys.exit()    # Check if the filter dimensions are odd    if (conv_filter.shape[0] * conv_filter.shape[1]) % 2 == 0:        print("Filter must have an odd size")        sys.exit()    # Feature map to hold the output of convolving the filter with the image    feature_map = np.zeros((image.shape[0] - conv_filter.shape[0] + 1,                            image.shape[1] - conv_filter.shape[1] + 1))    # Convolving the image by the filters    for filter_number in range(conv_filter.shape[0]):        print("Filter number: ", filter_number + 1)        # Getting filter from the bank        current_filter = conv_filter[filter_number, :]        if len(current_filter.shape()) > 2:            # Array holding the sum of all feature maps            conv_map = conv_(image[:, :, 0], curremt_filter[:, :, 0])            # Convolving each channel with the image and summing the results.            for channel_number in range(1, current_filter.shape()[-1]):                conv_map = conv_map + conv_(image[:, :, channel_number],                                            current_filter[:, :, channel_number])        # There is only a single channel to convolve        else:            conv_map = conv_(image, current_filter)def conv_(image, conv_filter):    filter_size = conv_filter.shape[1]    result = np.zeros((image.shape()))    # Looping through the image to apply the convolution operation.    for i in np.uint16(np.arange(start=filter_size / 2.0, stop=image.shape[0] - filter_size / 2.0 + 1)):        for j in np.uint16(np.arange(start=filter_size / 2.0, stop=image.shape[1] - filter_size / 2.0 + 1)):            current_region = image[i - np.uint16(np.floor(filter_size / 2.0)): i + np.uint16(np.ceil(filter_size / 2.0)),                          j - np.uint16(np.floor(filter_size / 2.0)):j + np.uint16(np.ceil(filter_size / 2.0))]            # Elementwise multiplication between the current region and the filter.            current_result = current_region * conv_filter            # Summing the result of multiplication.            conv_sum = np.sum(current_result)            # Saving the summation in the convolution layer feature map.            result[i, j] = conv_sum            final_result = result[np.uint16(filter_size / 2.0):result.shape[0] - np.uint16(filter_size / 2.0),                           np.uint16(filter_size / 2.0):result.shape[1] - np.uint16(filter_size / 2.0)]            return final_resultdef gaussian_filter(kernel_size, mean, variance):    """    :param kernel_size:    :param mean:    :param variance:    :return:    """    returndef main():    image_name = "dog.jpg"    image = Image.open(image_name)    # data = asarray(image)    # print(data.shape)    image = image.convert(mode='L')    data = asarray(image)    # print(data_gray.shape)    print(data.ndim)    # h, w = data.shape()    n = 3    # One filter on the first layer    l1_filter = np.zeros((1, n, n))    print(l1_filter.ndim)    print(l1_filter)    l1_filter[0, :, :] = np.array([[[-1, 0, 1],                                    [-1, 0, 1],                                    [-1, 0, 1]]])    print(l1_filter.shape)    print(l1_filter)if __name__ == "__main__":    main()